/**
 * @fileoverview Firestore Security Rules for ConnectSphere.
 *
 * Core Philosophy: This ruleset prioritizes a user-ownership model with shared access for collaborative features (chat groups). It uses path-based authorization and denormalized data to ensure security and performance. All write operations are strictly controlled, while read access is more permissive where appropriate.
 *
 * Data Structure:
 * - `/users/{userId}`: User profile information, accessible only by the user themselves.
 * - `/users/{userId}/status_updates/{statusId}`: Status updates for a user, accessible only by the user.
 * - `/chat_groups/{groupId}`: Group chat information, with membership managed by the `memberIds` array.
 * - `/chat_groups/{groupId}/messages/{messageId}`: Chat messages within a group, accessible to group members.
 * - `/users/{userId}/private_chats/{chatId}/messages/{messageId}`: Private chat messages between users, accessible to both users.
 * - `/affiliate_products/{productId}`: Affiliate products, publicly readable but writable only by admins.
 * - `/roles_admin/{userId}`: Indicates admin role. Existence of document grants admin privileges.
 *
 * Key Security Decisions:
 * - User listing is implicitly denied by the structure (no top-level `/users` collection).
 * - Read-only collections (none in this design) would use `allow get, list: if true;`.
 * - The default security posture for ambiguous relationships is strict owner-only access.
 * - Data validation is relaxed in this prototyping phase, focusing on authorization-critical fields.
 *
 * Denormalization for Authorization: The `ChatGroup` document contains a `memberIds` array to allow for efficient membership checks without additional reads.
 *
 * Structural Segregation: User-owned data (profiles, status updates) is stored under `/users/{userId}`, while admin-managed data (affiliate products) is stored in a separate top-level collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile information.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile: `request.auth.uid == 'user123'` and `request.resource.data.id == 'user123'`.
     * @allow (get) User with ID 'user123' reads their profile: `request.auth.uid == 'user123'`.
     * @allow (update) User with ID 'user123' updates their profile: `request.auth.uid == 'user123'` and `resource.data.id == 'user123'`.
     * @allow (delete) User with ID 'user123' deletes their profile: `request.auth.uid == 'user123'` and `resource.data.id == 'user123'`.
     * @deny (create) User with ID 'user456' attempts to create a profile for user 'user123': `request.auth.uid == 'user456'` and `request.resource.data.id == 'user123'`.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages status updates for a specific user.
     * @path /users/{userId}/status_updates/{statusId}
     * @allow (create) User with ID 'user123' creates a status update: `request.auth.uid == 'user123'` and `request.resource.data.userId == 'user123'`.
     * @allow (get) User with ID 'user123' reads their status update.
     * @allow (update) User with ID 'user123' updates their status update.
     * @allow (delete) User with ID 'user123' deletes their status update.
     * @deny (create) User with ID 'user456' attempts to create a status update for user 'user123': `request.auth.uid == 'user456'` and `request.resource.data.userId == 'user123'`.
     * @principle Enforces document ownership for writes, allows owner-only reads.
     */
    match /users/{userId}/status_updates/{statusId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages group chat information.
     * @path /chat_groups/{groupId}
     * @allow (create) Signed-in user can create a chat group. Must validate creatorId.
     * @allow (get) Signed-in user can read a chat group if they are a member.
     * @allow (update) Signed-in user can update a chat group if they are a member, and is also the creator.
     * @allow (delete) Signed-in user can delete a chat group if they are the creator.
     * @deny (create) User attempts to create a group with mismatched creatorId.
     * @principle Enforces membership for read/write, creator-only for delete.
     */
    match /chat_groups/{groupId} {
      allow get: if isSignedIn() && isGroupMember(groupId);
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && isGroupMember(groupId) && resource.data.creatorId == request.auth.uid;
      allow delete: if isSignedIn() && isExistingGroupOwner(groupId);
    }

    /**
     * @description Manages chat messages within a specific group.
     * @path /chat_groups/{groupId}/messages/{messageId}
     * @allow (create) Signed-in user can create a message if they are a member of the group.
     * @allow (get) Signed-in user can read a message if they are a member of the group.
     * @allow (update) Signed-in user can update a message if they are a member of the group.
     * @allow (delete) Signed-in user can delete a message if they are a member of the group.
     * @deny (create) User attempts to create a message in a group they are not a member of.
     * @principle Enforces group membership for all operations.
     */
    match /chat_groups/{groupId}/messages/{messageId} {
      allow get: if isSignedIn() && isGroupMember(groupId);
      allow list: if isSignedIn() && isGroupMember(groupId);
      allow create: if isSignedIn() && isGroupMember(groupId);
      allow update: if isSignedIn() && isGroupMember(groupId);
      allow delete: if isSignedIn() && isGroupMember(groupId);
    }

    /**
     * @description Manages direct messages between users.
     * @path /users/{userId}/private_chats/{chatId}/messages/{messageId}
     * @allow (create) User with ID 'user123' creates a message in their private chat: `request.auth.uid == 'user123'` and `request.resource.data.senderId == 'user123'`.
     * @allow (get) User with ID 'user123' reads a message in their private chat.
     * @allow (update) User with ID 'user123' updates a message in their private chat.
     * @allow (delete) User with ID 'user123' deletes a message in their private chat.
     * @deny (create) User with ID 'user456' attempts to create a message in user 'user123's private chat.
     * @principle Enforces document ownership for writes, allows owner-only reads.
     */
    match /users/{userId}/private_chats/{chatId}/messages/{messageId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages affiliate products. Publicly readable, but only admins can create/update/delete.
     * @path /affiliate_products/{productId}
     * @allow (get) Any user can read affiliate product information.
     * @allow (list) Any user can list affiliate products.
     * @allow (create) Only admins can create affiliate products, validating `adminId`.
     * @allow (update) Only admins can update affiliate products, validating existing `adminId`.
     * @allow (delete) Only admins can delete affiliate products.
     * @deny (create) Non-admin user attempts to create an affiliate product.
     * @principle Public read access, admin-only write access.
     */
    match /affiliate_products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update: if isSignedIn() && isAdmin() && resource.data.adminId == request.auth.uid;
      allow delete: if isSignedIn() && isAdmin() && resource.data.adminId == request.auth.uid;
    }

    /**
     * @description Indicates admin role. Existence of document grants admin privileges.
     * @path /roles_admin/{userId}
     * @allow (get) Any signed-in user can get an admin role.
     * @allow (list) Listing admin roles is not allowed.
     * @allow (create) Only admins can grant admin roles. Must be the same user.
     * @allow (update) Only admins can update admin roles. Must be the same user.
     * @allow (delete) Only admins can remove admin roles. Must be the same user.
     * @principle Admin-only access, self-assignment.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isSignedIn() && isAdmin() && isOwner(userId);
      allow update: if isSignedIn() && isAdmin() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isAdmin() && isExistingOwner(userId);
    }

  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }

  function isGroupMember(groupId) {
    return resource.data.memberIds.hasAny([request.auth.uid]);
  }

  function isExistingGroupOwner(groupId) {
    return isGroupOwner(groupId) && resource != null;
  }

  function isGroupOwner(groupId) {
        return get(/databases/$(database)/documents/chat_groups/$(groupId)).data.creatorId == request.auth.uid;
  }


  function isAdmin() {
    return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
  }
}