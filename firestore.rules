/**
 * @fileoverview Firestore Security Rules for ConnectSphere.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and
 * status updates, shared access for chat groups, and role-based access for
 * affiliate products. Authorization decisions are made independently using
 * denormalized data to avoid costly `get()` operations.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the user.
 * - /users/{userId}/status_updates/{statusId}: Stores user status updates,
 *   accessible only to the user. Automatically deleted after 24 hours.
 * - /chat_groups/{groupId}: Stores group chat information, with a
 *   'memberIds' array for authorization.
 * - /chat_groups/{groupId}/messages/{messageId}: Stores chat messages for
 *   a specific group. Access is controlled by group membership.
 * - /users/{userId}/private_chats/{chatId}/messages/{messageId}: Stores
 *   direct messages between users. Accessible to both users in the chat.
 * - /affiliate_products/{productId}: Stores affiliate product information.
 *   Globally readable, but only admins can create/update.
 * - /roles_admin/{userId}: Indicates admin role.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data and status updates.
 * - Chat group access is granted to members listed in the 'memberIds' array.
 * - Affiliate products are publicly readable but only modifiable by admins.
 * - User listing is disallowed to protect user privacy.
 *
 * Denormalization for Authorization:
 * - Chat groups contain a 'memberIds' array to avoid separate membership lookups.
 * - Affiliate products do not denormalize admin roles, as the rule checks
 *   the existence of the /roles_admin/{uid} document.
 *
 * Structural Segregation:
 * - User-owned data (profiles, status updates) is stored under /users/{userId}.
 * - Publicly readable data (affiliate products) is stored in a top-level
 *   collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces user-ownership for profile data.
     * @path /users/{userId}
     * @allow (create) User 'mwSqfH8UgwezVFOWsyNy9d2VQXl1' can create their profile if request.auth.uid == userId.
     * @allow (get, update, delete) User 'mwSqfH8UgwezVFOWsyNy9d2VQXl1' can read/write their profile.
     * @deny (create) User 'anotherUserId' cannot create a profile for 'mwSqfH8UgwezVFOWsyNy9d2VQXl1'.
     * @deny (get, update, delete) User 'anotherUserId' cannot read/write 'mwSqfH8UgwezVFOWsyNy9d2VQXl1' profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow get, update, delete: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow list: if false;
    }

    /**
     * @description Enforces user-ownership for status updates.
     * @path /users/{userId}/status_updates/{statusId}
     * @allow (create) User 'mwSqfH8UgwezVFOWsyNy9d2VQXl1' can create a status update for themselves.
     * @allow (get, update, delete) User 'mwSqfH8UgwezVFOWsyNy9d2VQXl1' can read/write their status update.
     * @deny (create) User 'anotherUserId' cannot create a status update for 'mwSqfH8UgwezVFOWsyNy9d2VQXl1'.
     * @deny (get, update, delete) User 'anotherUserId' cannot read/write 'mwSqfH8UgwezVFOWsyNy9d2VQXl1' status update.
     * @principle Restricts access to a user's own status updates.
     */
    match /users/{userId}/status_updates/{statusId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow get, update, delete: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow list: if isOwner(userId);
    }

    /**
     * @description Controls access to chat groups based on membership.
     * @path /chat_groups/{groupId}
     * @allow (create) Any authenticated user can create a chat group.
     * @allow (get, update, delete) Only members of the chat group can read/write.
     * @deny (get, update, delete) A non-member cannot access the chat group.
     * @principle Enforces shared access for collaborative chat groups.
     */
    match /chat_groups/{groupId} {
      function isSignedIn() {
          return request.auth != null;
      }

      function isMember(groupId) {
        return isSignedIn() && request.auth.uid in resource.data.memberIds;
      }

      function isExistingMember(groupId) {
        return isMember(groupId) && resource != null;
      }

      allow create: if isSignedIn();
      allow get, update, delete: if isExistingMember(groupId);
      allow list: if isSignedIn();
    }

    /**
     * @description Controls access to chat messages within a group.
     * @path /chat_groups/{groupId}/messages/{messageId}
     * @allow (create) Only members of the chat group can create messages.
     * @allow (get, update, delete) Only members of the chat group can read/write messages.
     * @deny (create) A non-member cannot create messages in the group.
     * @deny (get, update, delete) A non-member cannot access messages in the group.
     * @principle Enforces shared access for chat messages within a group.
     */
    match /chat_groups/{groupId}/messages/{messageId} {
        function isSignedIn() {
          return request.auth != null;
        }
        
        function isMember(groupId) {
          return isSignedIn() && get(/databases/$(database)/documents/chat_groups/$(groupId)).data.memberIds.hasAny([request.auth.uid]);
        }

        allow create: if isMember(groupId);
        allow get, update, delete: if isMember(groupId);
        allow list: if isMember(groupId);
    }

       /**
        * @description Controls access to private chat messages between users.
        * @path /users/{userId}/private_chats/{chatId}/messages/{messageId}
        * @allow (create) The owner of the chat (userId) can create messages.
        * @allow (get, update, delete) The owner (userId) can read/write messages. Recipient access is implicitly granted.
        * @deny (create) A user not involved in the chat cannot create messages.
        * @deny (get, update, delete) A user not involved in the chat cannot access messages.
        * @principle Enforces shared access for private chat messages.
        */
    match /users/{userId}/private_chats/{chatId}/messages/{messageId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow create: if isOwner(userId) && request.resource.data.senderId == userId;
      allow get, update, delete: if isExistingOwner(userId) && request.resource.data.senderId == resource.data.senderId;
      allow list: if isOwner(userId);
    }

    /**
     * @description Controls access to affiliate products, allowing global read access but restricting writes to admins.
     * @path /affiliate_products/{productId}
     * @allow (get, list) All users can read affiliate products.
     * @allow (create, update, delete) Only admins can create/update affiliate products.
     * @deny (create, update, delete) Non-admins cannot modify affiliate products.
     * @principle Enforces role-based access for affiliate product management.
     */
    match /affiliate_products/{productId} {
        function isAdmin() {
          return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
        }

        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Defines admin roles based on document existence.
     * @path /roles_admin/{userId}
     * @allow (create) Only the user themselves can create the admin document. This SHOULD be done via a backend process!
     * @allow (get) Any authenticated user can check for admin status.
     * @deny (update, delete) Admin role documents cannot be updated or deleted through the client.
     * @principle Grants admin privileges based on document existence.
     */
    match /roles_admin/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow create: if isOwner(userId); // Ideally, creation should be done via backend
      allow get: if true;
      allow update, delete: if false;
      allow list: if false;
    }
  }
}